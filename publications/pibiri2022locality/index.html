<!DOCTYPE html>
<html lang="en-us">

  <head>
<!-- Begin Web-Stat code v 7.0 -->
<span id="wts2185304"></span>
<script>var wts=document.createElement('script');wts.async=true;
wts.src='https://app.ardalio.com/log7.js';document.head.appendChild(wts);
wts.onload = function(){ wtslog7(2185304,4); };
</script><noscript><a href="https://www.web-stat.com">
<img src="https://app.ardalio.com/7/4/2185304.png" 
alt="Web-Stat web statistics"></a></noscript>
<!-- End Web-Stat code v 7.0 -->
  <!-- Hotjar Tracking Code for https://learning2hash.github.io/ -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1843243,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-109544763-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-109544763-1');
</script>
<script>
    window.MathJax = {
      tex: {
        inlineMath: [["\\(","\\)"]],
        displayMath: [["\\[","\\]"]],
      },
      options: {
        processHtmlClass: "mathjax-content",
        processEscapes: true,
      }
    };
  </script>
  <script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="keywords" content="machine learning, hashing, approximate nearest neighbour search, lsh, learning-to-hash">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Locality-preserving Minimal Perfect Hashing Of K-mers | Awesome Learning to Hash</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Locality-preserving Minimal Perfect Hashing Of K-mers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Minimal perfect hashing is the problem of mapping a static set of \(n\) distinct keys into the address space \(\{1,\ldots,n\}\) bijectively. It is well-known that \(nlog_2(e)\) bits are necessary to specify a minimal perfect hash function (MPHF) \(f\), when no additional knowledge of the input keys is to be used. However, it is often the case in practice that the input keys have intrinsic relationships that we can exploit to lower the bit complexity of \(f\). For example, consider a string and the set of all its distinct \(k\)-mers as input keys: since two consecutive \(k\)-mers share an overlap of \(k-1\) symbols, it seems possible to beat the classic \(log_2(e)\) bits/key barrier in this case. Moreover, we would like \(f\) to map consecutive \(k\)-mers to consecutive addresses, as to also preserve as much as possible their relationship in the codomain. This is a useful feature in practice as it guarantees a certain degree of locality of reference for \(f\), resulting in a better evaluation time when querying consecutive \(k\)-mers. Motivated by these premises, we initiate the study of a new type of locality-preserving MPHF designed for \(k\)-mers extracted consecutively from a collection of strings. We design a construction whose space usage decreases for growing \(k\) and discuss experiments with a practical implementation of the method: in practice, the functions built with our method can be several times smaller and even faster to query than the most efficient MPHFs in the literature." />
<meta property="og:description" content="Minimal perfect hashing is the problem of mapping a static set of \(n\) distinct keys into the address space \(\{1,\ldots,n\}\) bijectively. It is well-known that \(nlog_2(e)\) bits are necessary to specify a minimal perfect hash function (MPHF) \(f\), when no additional knowledge of the input keys is to be used. However, it is often the case in practice that the input keys have intrinsic relationships that we can exploit to lower the bit complexity of \(f\). For example, consider a string and the set of all its distinct \(k\)-mers as input keys: since two consecutive \(k\)-mers share an overlap of \(k-1\) symbols, it seems possible to beat the classic \(log_2(e)\) bits/key barrier in this case. Moreover, we would like \(f\) to map consecutive \(k\)-mers to consecutive addresses, as to also preserve as much as possible their relationship in the codomain. This is a useful feature in practice as it guarantees a certain degree of locality of reference for \(f\), resulting in a better evaluation time when querying consecutive \(k\)-mers. Motivated by these premises, we initiate the study of a new type of locality-preserving MPHF designed for \(k\)-mers extracted consecutively from a collection of strings. We design a construction whose space usage decreases for growing \(k\) and discuss experiments with a practical implementation of the method: in practice, the functions built with our method can be several times smaller and even faster to query than the most efficient MPHFs in the literature." />
<link rel="canonical" href="https://learning2hash.github.io/publications/pibiri2022locality/" />
<meta property="og:url" content="https://learning2hash.github.io/publications/pibiri2022locality/" />
<meta property="og:site_name" content="Awesome Learning to Hash" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-15T05:17:51-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Locality-preserving Minimal Perfect Hashing Of K-mers" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-15T05:17:51-05:00","datePublished":"2025-06-15T05:17:51-05:00","description":"Minimal perfect hashing is the problem of mapping a static set of \\(n\\) distinct keys into the address space \\(\\{1,\\ldots,n\\}\\) bijectively. It is well-known that \\(nlog_2(e)\\) bits are necessary to specify a minimal perfect hash function (MPHF) \\(f\\), when no additional knowledge of the input keys is to be used. However, it is often the case in practice that the input keys have intrinsic relationships that we can exploit to lower the bit complexity of \\(f\\). For example, consider a string and the set of all its distinct \\(k\\)-mers as input keys: since two consecutive \\(k\\)-mers share an overlap of \\(k-1\\) symbols, it seems possible to beat the classic \\(log_2(e)\\) bits/key barrier in this case. Moreover, we would like \\(f\\) to map consecutive \\(k\\)-mers to consecutive addresses, as to also preserve as much as possible their relationship in the codomain. This is a useful feature in practice as it guarantees a certain degree of locality of reference for \\(f\\), resulting in a better evaluation time when querying consecutive \\(k\\)-mers. Motivated by these premises, we initiate the study of a new type of locality-preserving MPHF designed for \\(k\\)-mers extracted consecutively from a collection of strings. We design a construction whose space usage decreases for growing \\(k\\) and discuss experiments with a practical implementation of the method: in practice, the functions built with our method can be several times smaller and even faster to query than the most efficient MPHFs in the literature.","headline":"Locality-preserving Minimal Perfect Hashing Of K-mers","mainEntityOfPage":{"@type":"WebPage","@id":"https://learning2hash.github.io/publications/pibiri2022locality/"},"url":"https://learning2hash.github.io/publications/pibiri2022locality/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.svg">
  <link rel="search" href="/public/opensearchdescription.xml" 
      type="application/opensearchdescription+xml" 
      title="learning2hash" />

  <script src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
  
  <link rel="stylesheet" type="text/css" href="//cdn.datatables.net/1.10.16/css/jquery.dataTables.min.css">
  <script type="text/javascript" charset="utf8" src="//cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js"></script>
</head>


  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <body class="theme-base-0c layout-reverse">

    <a href='/contributing.html' class='ribbon'>Add your paper to Learning2Hash</a>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Awesome Learning to Hash
        </a>
      </h1>
      <p class="lead">A Webpage dedicated to the latest research on Hash Function Learning. Maintained by <a href="http://sjmoran.github.io/">Sean Moran</a>.</p>
    </div>

    <nav class="sidebar-nav">
      <div class="sidebar-item">
        <p style="font-size: 12px">
          Search related work 
          <input type='text' id='searchTarget' size="16"/> 
          <button onClick="search();">Go</button>
        </p>
      </div>
      <a class="sidebar-nav-item" href="/papers.html">All Papers</a>
      <a class="sidebar-nav-item" href="/tags.html">Papers by Tag</a>
      <a class="sidebar-nav-item" href="/tsne-viz.html">2D Map of Papers</a>
      <a class="sidebar-nav-item" href="/topic-viz.html">Topic-based Explorer</a>
      <a class="sidebar-nav-item" href="/base-taxonomy/">Core Taxonomy</a>
      <a class="sidebar-nav-item" href="/base-taxonomy/datasets.html">Datasets</a>
      <a class="sidebar-nav-item" href="/tutorial.html">Tutorial</a>
      <a class="sidebar-nav-item" href="/resources.html">Resources, Courses &#38; Events</a>
      <a class="sidebar-nav-item" href="/contributing.html">Contributing</a>
    </nav>

    <div class="sidebar-item">
      <p style="font-size: 12px">
        Contact <a href="http://www.seanjmoran.com">Sean Moran</a> about this survey or website.
        <span style="font-size: 9px">
          Made with <a href="https://jekyllrb.com">Jekyll</a> and <a href="https://github.com/poole/hyde">Hyde</a>.
        </span>
      </p>
    </div>
  </div>
</div>

<script>
$("#searchTarget").keydown(function (e) {	
  if (e.keyCode == 13) {
    search();
  }
});

function search() {
  try {
    ga('send', 'event', 'search', 'search', $("#searchTarget").val());
  } finally {
    window.location = "/papers.html#" + $("#searchTarget").val();
  }
}
</script>


    <div class="content container">
      <div class="page mathjax-content">
  <h1 class="page-title">Locality-preserving Minimal Perfect Hashing Of K-mers</h1>
  <h5>Giulio Ermanno Pibiri, Yoshihiro Shibuya, Antoine Limasset. Arxiv 2022</h5>
  
  <p>
    
      [<a href="https://arxiv.org/abs/2210.13097" target="_blank">Paper</a>]
    
    &nbsp;<a href='http://scholar.google.com/scholar?q=Locality-preserving%20Minimal%20Perfect%20Hashing%20Of%20K-mers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
    &nbsp;<a href='https://www.semanticscholar.org/search?q=Locality-preserving%20Minimal%20Perfect%20Hashing%20Of%20K-mers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
    <br/>
    
      <span class="tag"><a href="/tags.html#Independent">Independent</a></span>
    
      <span class="tag"><a href="/tags.html#Unimodal">Unimodal</a></span>
    
      <span class="tag"><a href="/tags.html#Evaluation">Evaluation</a></span>
    
      <span class="tag"><a href="/tags.html#Shallow">Shallow</a></span>
    
      <span class="tag"><a href="/tags.html#Hashing">Hashing</a></span>
    
  </p>
  
  <p><p>Minimal perfect hashing is the problem of mapping a static set of \(n\)
distinct keys into the address space \(\{1,\ldots,n\}\) bijectively. It is
well-known that \(nlog_2(e)\) bits are necessary to specify a minimal perfect
hash function (MPHF) \(f\), when no additional knowledge of the input keys is to
be used. However, it is often the case in practice that the input keys have
intrinsic relationships that we can exploit to lower the bit complexity of \(f\).
For example, consider a string and the set of all its distinct \(k\)-mers as
input keys: since two consecutive \(k\)-mers share an overlap of \(k-1\) symbols,
it seems possible to beat the classic \(log_2(e)\) bits/key barrier in this
case. Moreover, we would like \(f\) to map consecutive \(k\)-mers to consecutive
addresses, as to also preserve as much as possible their relationship in the
codomain. This is a useful feature in practice as it guarantees a certain
degree of locality of reference for \(f\), resulting in a better evaluation time
when querying consecutive \(k\)-mers. Motivated by these premises, we initiate
the study of a new type of locality-preserving MPHF designed for \(k\)-mers
extracted consecutively from a collection of strings. We design a construction
whose space usage decreases for growing \(k\) and discuss experiments with a
practical implementation of the method: in practice, the functions built with
our method can be several times smaller and even faster to query than the most
efficient MPHFs in the literature.</p>
</p>

  <h6>Similar Work</h6>
  <p>
    <ul id="relwork"></ul>
  </p>

  <script defer>
    $(document).ready(function() {
      $.getJSON("/publications-metadata/pibiri2022locality.json", function(data) {
        var num_papers = data.length;
        var html = "";
        for (var i = 0; i < num_papers; i++) {
          html += '<li><a href="/publications/' + data[i][0] + '">'+ data[i][1] +'</a></li>';
        }
        $("#relwork").append(html);
      }).fail(function() {
        console.error("Failed to load related work metadata.");
      });
    });
  </script>

</div>

    </div>

  </body>
</html>
