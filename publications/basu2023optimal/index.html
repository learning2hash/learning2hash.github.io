<!DOCTYPE html>
<html lang="en-us">

  <head>
<!-- Begin Web-Stat code v 7.0 -->
<span id="wts2185304"></span>
<script>var wts=document.createElement('script');wts.async=true;
wts.src='https://app.ardalio.com/log7.js';document.head.appendChild(wts);
wts.onload = function(){ wtslog7(2185304,4); };
</script><noscript><a href="https://www.web-stat.com">
<img src="https://app.ardalio.com/7/4/2185304.png" 
alt="Web-Stat web statistics"></a></noscript>
<!-- End Web-Stat code v 7.0 -->
  <!-- Hotjar Tracking Code for https://learning2hash.github.io/ -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1843243,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-109544763-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-109544763-1');
</script>
<script>
    window.MathJax = {
      tex: {
        inlineMath: [["\\(","\\)"]],
        displayMath: [["\\[","\\]"]],
      },
      options: {
        processHtmlClass: "mathjax-content",
        processEscapes: true,
      }
    };
  </script>
  <script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="keywords" content="machine learning, hashing, approximate nearest neighbour search, lsh, learning-to-hash">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Optimal Storage Codes On Graphs With Fixed Locality | Awesome Learning to Hash</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Optimal Storage Codes On Graphs With Fixed Locality" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Storage codes on graphs are an instance of codes with locality, which are used in distributed storage schemes to provide local repairability. Specifically, the nodes of the graph correspond to storage servers, and the neighbourhood of each server constitute the set of servers it can query to repair its stored data in the event of a failure. A storage code on a graph with (n)-vertices is a set of (n)-length codewords over (\field_q) where the (i)th codeword symbol is stored in server (i), and it can be recovered by querying the neighbours of server (i) according to the underlying graph. In this work, we look at binary storage codes whose repair function is the parity check, and characterise the tradeoff between the locality of the code and its rate. Specifically, we show that the maximum rate of a code on (n) vertices with locality (r) is bounded between (1-1/n\lceil n/(r+1)\rceil) and (1-1/n\lceil n/(r+1)\rceil). The lower bound on the rate is derived by constructing an explicit family of graphs with locality (r), while the upper bound is obtained via a lower bound on the binary-field rank of a class of symmetric binary matrices. Our upper bound on maximal rate of a storage code matches the upper bound on the larger class of codes with locality derived by Tamo and Barg. As a corollary to our result, we obtain the following asymptotic separation result: given a sequence (r(n), n\geq 1), there exists a sequence of graphs on (n)-vertices with storage codes of rate (1-o(1)) if and only if (r(n)=\omega(1))." />
<meta property="og:description" content="Storage codes on graphs are an instance of codes with locality, which are used in distributed storage schemes to provide local repairability. Specifically, the nodes of the graph correspond to storage servers, and the neighbourhood of each server constitute the set of servers it can query to repair its stored data in the event of a failure. A storage code on a graph with (n)-vertices is a set of (n)-length codewords over (\field_q) where the (i)th codeword symbol is stored in server (i), and it can be recovered by querying the neighbours of server (i) according to the underlying graph. In this work, we look at binary storage codes whose repair function is the parity check, and characterise the tradeoff between the locality of the code and its rate. Specifically, we show that the maximum rate of a code on (n) vertices with locality (r) is bounded between (1-1/n\lceil n/(r+1)\rceil) and (1-1/n\lceil n/(r+1)\rceil). The lower bound on the rate is derived by constructing an explicit family of graphs with locality (r), while the upper bound is obtained via a lower bound on the binary-field rank of a class of symmetric binary matrices. Our upper bound on maximal rate of a storage code matches the upper bound on the larger class of codes with locality derived by Tamo and Barg. As a corollary to our result, we obtain the following asymptotic separation result: given a sequence (r(n), n\geq 1), there exists a sequence of graphs on (n)-vertices with storage codes of rate (1-o(1)) if and only if (r(n)=\omega(1))." />
<link rel="canonical" href="https://learning2hash.github.io/publications/basu2023optimal/" />
<meta property="og:url" content="https://learning2hash.github.io/publications/basu2023optimal/" />
<meta property="og:site_name" content="Awesome Learning to Hash" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-08-14T11:10:36-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Optimal Storage Codes On Graphs With Fixed Locality" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-14T11:10:36-05:00","datePublished":"2025-08-14T11:10:36-05:00","description":"Storage codes on graphs are an instance of codes with locality, which are used in distributed storage schemes to provide local repairability. Specifically, the nodes of the graph correspond to storage servers, and the neighbourhood of each server constitute the set of servers it can query to repair its stored data in the event of a failure. A storage code on a graph with (n)-vertices is a set of (n)-length codewords over (\\field_q) where the (i)th codeword symbol is stored in server (i), and it can be recovered by querying the neighbours of server (i) according to the underlying graph. In this work, we look at binary storage codes whose repair function is the parity check, and characterise the tradeoff between the locality of the code and its rate. Specifically, we show that the maximum rate of a code on (n) vertices with locality (r) is bounded between (1-1/n\\lceil n/(r+1)\\rceil) and (1-1/n\\lceil n/(r+1)\\rceil). The lower bound on the rate is derived by constructing an explicit family of graphs with locality (r), while the upper bound is obtained via a lower bound on the binary-field rank of a class of symmetric binary matrices. Our upper bound on maximal rate of a storage code matches the upper bound on the larger class of codes with locality derived by Tamo and Barg. As a corollary to our result, we obtain the following asymptotic separation result: given a sequence (r(n), n\\geq 1), there exists a sequence of graphs on (n)-vertices with storage codes of rate (1-o(1)) if and only if (r(n)=\\omega(1)).","headline":"Optimal Storage Codes On Graphs With Fixed Locality","mainEntityOfPage":{"@type":"WebPage","@id":"https://learning2hash.github.io/publications/basu2023optimal/"},"url":"https://learning2hash.github.io/publications/basu2023optimal/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.svg">
  <link rel="search" href="/public/opensearchdescription.xml" 
      type="application/opensearchdescription+xml" 
      title="learning2hash" />

  <script src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
  
  <link rel="stylesheet" type="text/css" href="//cdn.datatables.net/1.10.16/css/jquery.dataTables.min.css">
  <script type="text/javascript" charset="utf8" src="//cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js"></script>
</head>


  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <body class="theme-base-0c layout-reverse">

    <a href='/contributing.html' class='ribbon'>Add your paper to Learning2Hash</a>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Awesome Learning to Hash
        </a>
      </h1>
      <p class="lead">A Webpage dedicated to the latest research on Hash Function Learning. Maintained by <a href="http://sjmoran.github.io/">Sean Moran</a>.</p>
    </div>

    <nav class="sidebar-nav">
      <div class="sidebar-item">
        <p style="font-size: 12px">
          Search related work 
          <input type='text' id='searchTarget' size="16"/> 
          <button onClick="search();">Go</button>
        </p>
      </div>
      <a class="sidebar-nav-item" href="/papers.html">All Papers</a>
      <a class="sidebar-nav-item" href="/tags.html">Papers by Tag</a>
      <a class="sidebar-nav-item" href="/tsne-viz.html">2D Map of Papers</a>
      <a class="sidebar-nav-item" href="/topic-viz.html">Topic Explorer</a>
      <a class="sidebar-nav-item" href="/author-viz.html">Author Explorer </a>
      <a class="sidebar-nav-item" href="/tutorial.html">Tutorial</a>
      <a class="sidebar-nav-item" href="/resources.html">Resources, Courses &#38; Events</a>
      <a class="sidebar-nav-item" href="/contributing.html">Contributing</a>
    </nav>

    <div class="sidebar-item">
      <p style="font-size: 12px">
        Contact <a href="http://www.seanjmoran.com">Sean Moran</a> about this survey or website.
        <span style="font-size: 9px">
          Made with <a href="https://jekyllrb.com">Jekyll</a> and <a href="https://github.com/poole/hyde">Hyde</a>.
        </span>
      </p>
    </div>
  </div>
</div>

<script>
$("#searchTarget").keydown(function (e) {	
  if (e.keyCode == 13) {
    search();
  }
});

function search() {
  try {
    ga('send', 'event', 'search', 'search', $("#searchTarget").val());
  } finally {
    window.location = "/papers.html#" + $("#searchTarget").val();
  }
}
</script>


    <div class="content container">
      <div class="page">
  <h1 class="page-title">Optimal Storage Codes On Graphs With Fixed Locality</h1>
  <h5>
  
    
      Sabyasachi Basu, Manuj Mukherjee
    
  
  . Arxiv
   2023
  
    – <span>1 citation</span>
  
  </h5>
  <p>
    
      [<a href="https://arxiv.org/abs/2307.08680" target="_blank">Paper</a>]
    
    &nbsp;<a href='http://scholar.google.com/scholar?q=Optimal Storage Codes On Graphs With Fixed Locality' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
    &nbsp;<a href='https://www.semanticscholar.org/search?q=Optimal Storage Codes On Graphs With Fixed Locality' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
    <br/>
    
      <tag><a href="/tags.html#Compact Codes">Compact Codes</a></tag>
    
      <tag><a href="/tags.html#Graph Based ANN">Graph Based ANN</a></tag>
    
      <tag><a href="/tags.html#Memory Efficiency">Memory Efficiency</a></tag>
    
  </p>
  <p><p>Storage codes on graphs are an instance of <em>codes with locality</em>, which
are used in distributed storage schemes to provide local repairability.
Specifically, the nodes of the graph correspond to storage servers, and the
neighbourhood of each server constitute the set of servers it can query to
repair its stored data in the event of a failure. A storage code on a graph
with (n)-vertices is a set of (n)-length codewords over (\field_q) where the
(i)th codeword symbol is stored in server (i), and it can be recovered by
querying the neighbours of server (i) according to the underlying graph.
  In this work, we look at binary storage codes whose repair function is the
parity check, and characterise the tradeoff between the locality of the code
and its rate. Specifically, we show that the maximum rate of a code on (n)
vertices with locality (r) is bounded between (1-1/n\lceil n/(r+1)\rceil) and
(1-1/n\lceil n/(r+1)\rceil). The lower bound on the rate is derived by
constructing an explicit family of graphs with locality (r), while the upper
bound is obtained via a lower bound on the binary-field rank of a class of
symmetric binary matrices. Our upper bound on maximal rate of a storage code
matches the upper bound on the larger class of codes with locality derived by
Tamo and Barg. As a corollary to our result, we obtain the following asymptotic
separation result: given a sequence (r(n), n\geq 1), there exists a sequence of
graphs on (n)-vertices with storage codes of rate (1-o(1)) if and only if
(r(n)=\omega(1)).</p>
</p>

  <h6>Similar Work</h6>
  <p>
    <ul id="relwork">

    </ul>
  </p>

 <script>  
    $(document).ready(
      function() {
        $.getJSON("/publications-metadata/basu2023optimal.json", function(data) {
          num_papers = data.length;
          html = "";
          for (let i=0; i < num_papers; i++) {
              html += '<li><a href="/publications/' + data[i][0] + '">'+ data[i][1] +'</a></li>'
          }
          $("#relwork").append(html);
        });
      });
  </script>


</div>

    </div>

  </body>
</html>
