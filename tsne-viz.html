---
layout: default
title: Visualization of Publications on Learning to Hash
description: An interactive t-SNE map of Learning to Hash with global search, a cluster legend, and optional node sizing by citations.
---

<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
/* ====== Simple, safe container (no sidebar subtraction) ====== */
:root{ --page-gutter: clamp(12px, 2vw, 24px); }

/* Centered wrapper with comfy gutters */
.full-bleed-right{
  box-sizing:border-box;
  width:100%;
  max-width:1200px;          /* adjust if you want wider/narrower on desktop */
  margin-left:auto;
  margin-right:auto;
  padding-left:var(--page-gutter);
  padding-right:var(--page-gutter);
}

/* Children can be full width inside this container */
.full-bleed-right > * { max-width: 100% !important; }

/* Map container grows with parent; friendly min height but fluid */
#paperviz {
  width:100%;
  position:relative;         /* so floating UI anchors to this */
  min-height: 50vh;          /* proportional, no fixed px */
  background:#fff;
  border:1px solid #eee; border-radius:8px;
  box-shadow: 0 1px 2px rgba(0,0,0,.035);
  overflow: hidden;
}

/* Floating map UI (inside the map) */
#paperviz .map-ui{
  position:absolute;
  right:10px;
  top:12px;
  display:flex;
  flex-direction:column;
  gap:12px;
  z-index: 5;
}
.fab{
  width: 36px; height: 36px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  background: #ffffff;
  box-shadow: 0 2px 6px rgba(0,0,0,.08);
  font: 600 18px/36px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  text-align:center; cursor:pointer;
  transition: transform .08s ease, background-color .15s ease, box-shadow .15s ease;
}
.fab:hover{ background:#f5f7fb; transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,.10); }
.fab:active{ transform: translateY(0); }

/* Gesture hint (auto-fades) */
#paperviz .gesture-hint{
  position: absolute;
  right: 56px; top: 16px;
  background: rgba(34,34,34,.85); color:#fff;
  padding: 6px 10px; border-radius: 8px; font-size:.78rem;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  opacity: 0; pointer-events: none; transition: opacity .25s ease;
  z-index: 5;
}
#paperviz .gesture-hint.show{ opacity: 1; }

/* Legend block sits UNDER the map, full width and responsive */
#cluster-legend-wrapper{
  margin-top:16px;
  padding: 12px;
  border:1px solid #eee; border-radius:8px; background:#fff;
  box-shadow: 0 1px 2px rgba(0,0,0,.035);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}

/* Responsive legend grid so it never squeezes layout */
#cluster-legend {
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap:12px;
}

/* Smaller legend text */
#cluster-legend .legend-item {
  background:#f9f9f9;
  padding:10px 12px;
  border-radius:8px;
  box-shadow: 0 1px 2px rgba(0,0,0,.05);
  transition: background-color .2s, transform .12s ease;
  cursor:pointer;
  font-size: .86rem;
  line-height: 1.35;
}
#cluster-legend .legend-item:hover { background:#f0f3f7; transform: translateY(-1px); }
#cluster-legend .legend-title { font-weight: 600; margin-bottom: 6px; font-size: .9rem; }
#cluster-legend .legend-tag { font-size: .78rem; opacity: .9; margin-left: 6px; }

/* Tooltip */
.tooltip { pointer-events:none; }

/* Controls â€” compact, neutral, fluid */
.controls { display:flex; flex-wrap:wrap; align-items:flex-start; justify-content:space-between; gap:.6rem; margin:.6rem 0 .9rem; }
.search { display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
.search label { font-weight:700; font-size:.85rem; }
.search input[type="search"], .search input[type="text"] {
  width: clamp(180px, 28vw, 420px);
  padding:.25rem .4rem; border:1px solid #aaa; border-radius:4px; font-size:.85rem; background:#f8f9fa;
}
.search input:focus { outline:none; border-color:#0c5fce; box-shadow:0 0 0 2px rgba(26,115,232,.25); }
.search button { padding:.25rem .5rem; font-size:.85rem; border:1px solid #aaa; border-radius:4px; background:#f8f9fa; cursor:pointer; }
.search button:hover { background:#e2e2e2; }
.small { color:#6b7280; font-size:.9em; }
.dash { opacity:.6; }

/* Year slider tweaks */
.range-wrap{ display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
input[type="range"]{ accent-color:#1a73e8; }

/* Narrow screens */
@media (max-width: 680px){
  .search input[type="text"] { width:100%; }
  #paperviz { min-height: 360px; }
}
</style>

<h2>2D Map of Papers</h2>
<p>
  Each dot represents a paper in this collection, positioned using t-SNE based on its content. Use the search bar to filter by title, authors, abstract, or tags.
</p>

<div class="full-bleed-right">
  <!-- Unified controls -->
  <div class="controls" role="search">
    <div class="search">
      <label for="filtermap"><strong>Search</strong></label>
      <input type="text" spellcheck="false" id="filtermap" placeholder="ðŸ” Search papersâ€¦" aria-label="Search papers" />
      <button id="clearSearch" type="button">Clear</button>
      <span id="matchCount" class="small"></span>
    </div>
  </div>

  <!-- View control (size by citations) -->
  <div class="controls" style="margin-top:-.4rem;">
    <div class="search">
      <label for="sizeByCitations"><strong>View</strong></label>
      <div>
        <input type="checkbox" id="sizeByCitations" /> <span class="small">Citations</span>
      </div>
    </div>
  </div>

  <!-- Year filter (dual range) -->
  <div class="controls" id="yearControls" style="margin-top:-.6rem; display:none;">
    <div class="search">
      <label for="yearMin"><strong>Year</strong></label>
      <div class="range-wrap">
        <input type="range" id="yearMin" min="2000" max="2025" step="1" value="2000" aria-label="Minimum year">
        <input type="range" id="yearMax" min="2000" max="2025" step="1" value="2025" aria-label="Maximum year">
        <div class="small">
          <span id="yearMinVal">2000</span>â€“<span id="yearMaxVal">2025</span>
        </div>
        <button id="clearYear" type="button" aria-label="Reset year filter">All years</button>
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="paperviz">
    <div id="loadingViz" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;">
      Loading visualization...
    </div>

    <!-- Floating map UI -->
    <div class="map-ui" aria-label="Map controls">
      <button class="fab" id="zoom_in"  aria-label="Zoom in"  title="Zoom in (+)">+</button>
      <button class="fab" id="zoom_out" aria-label="Zoom out" title="Zoom out (âˆ’)">âˆ’</button>
      <button class="fab" id="reset_view" aria-label="Reset view" title="Reset view (R)">âŒ‚</button>
    </div>

    <!-- One-time gesture hint -->
    <div class="gesture-hint" id="gestureHint">
      Drag to pan Â· Scroll/Pinch to zoom
    </div>
  </div>

  <!-- Legend UNDER the map -->
  <section id="cluster-legend-wrapper" aria-label="Cluster Legend">
    <h3 style="margin: 0 0 8px;">ðŸ§­ Cluster Legend</h3>
    <button id="resetClusters" style="margin-bottom:10px;">Show All Clusters</button>
    <div id="cluster-legend"></div>
  </section>
</div>

<p>
  Please consider <a href="/contributing.html">contributing</a> by updating the information of existing papers or adding new work.
</p>

<script src="https://d3js.org/d3.v6.js"></script>

<script>
/* ----------------- Tap-to-toggle for tooltip (mobile) ----------------- */
document.addEventListener('click', function(e){
  const isInfo = e.target.closest('.info[data-tooltip]');
  document.querySelectorAll('.info[data-show]').forEach(el => { if (el !== isInfo) el.removeAttribute('data-show'); });
  if (isInfo) { e.preventDefault(); isInfo.toggleAttribute('data-show'); }
}, { passive: false });

/* ----------------- State ----------------- */
var allData = [];
var filteredData = [];
var selectedCluster = null;
var updateVisualization = () => {};
var currentTransform = d3.zoomIdentity;

/* Year slider state */
var yearMinBound = null;
var yearMaxBound = null;
var selectedYearMin = null;
var selectedYearMax = null;

/* ----------------- Search helper ----------------- */
var isMatch = function(d, searchTerm) {
  return searchTerm.length >= 3 && d._searchText.includes(searchTerm);
};

/* ----------------- Layout / D3 base ----------------- */
var margin = {top: 10, right: 24, bottom: 30, left: 40};
var width = 320 - margin.left - margin.right;   // initial; ResizeObserver fixes immediately
var height = 260 - margin.top - margin.bottom;

var svg = d3.select("#paperviz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var zoomLayer = svg.append("g");
var color = d3.scaleOrdinal(d3.schemeCategory10);

/* Keep domains generous; TSNE coordinates should fit here */
var x = d3.scaleLinear().domain([-25, 25]).range([0, width]);
var y = d3.scaleLinear().domain([-25, 25]).range([height, 0]);

var zoom = d3.zoom()
  .scaleExtent([0.4, 20]) // allow a wider zoom-out range
  .on("zoom", function(event) {
    currentTransform = event.transform;
    zoomLayer.attr("transform", event.transform);
  });

d3.select("#paperviz svg").call(zoom);

/* Tooltip */
var tooltip = d3.select("#paperviz")
  .append("div")
  .style("opacity", 0)
  .attr("class", "tooltip")
  .style("background-color", "rgb(81, 81, 81)")
  .style("max-width", "min(90vw, 42ch)")
  .style("color", "white")
  .style("border-width", "0px")
  .style("border-radius", "10px")
  .style("padding", "10px")
  .style("position", "absolute");

var mouseover = function() { tooltip.style("opacity", 1); };
var mousemove = function(event, d) {
  const tags = (d.tags || []).slice(0, 6).map(t => `<tag>${t}</tag>`).join(" ");
  tooltip.html(`
    <div style="font-weight:600; margin-bottom:4px;">${d.title}</div>
    <div style="font-size:12px; opacity:.9;">
      ${d.conference || "â€”"} â€¢ ${d.year || "n/a"} â€¢ Citations: ${d.citations || 0}
    </div>
    <div style="margin-top:6px; font-size:12px;">${tags}</div>
  `);

  const container = document.getElementById("paperviz");
  const cr = container.getBoundingClientRect();
  const ttNode = tooltip.node();
  const ttWidth = ttNode.offsetWidth;
  const ttHeight = ttNode.offsetHeight;

  const mx = event.clientX - cr.left;
  const my = event.clientY - cr.top;

  const offsetY = 12;
  let left = mx - ttWidth / 2;
  let top  = my  - ttHeight - offsetY;

  const pad = 8;
  left = Math.max(pad, Math.min(left, cr.width  - ttWidth  - pad));
  top  = Math.max(pad, Math.min(top,  cr.height - ttHeight - pad));

  tooltip.style("left", left + "px").style("top", top + "px");
};
var mouseleave = function() { tooltip.style("opacity", 0); };
var click_link = function(event, d) { window.location.href = "/publications/" + d.key + "/"; };

/* ----------------- URL State helpers ----------------- */
function getState() {
  return {
    q: d3.select("#filtermap").property("value"),
    cluster: selectedCluster,
    y0: selectedYearMin,
    y1: selectedYearMax
  };
}
function setStateFromURL() {
  const p = new URLSearchParams(location.search);
  if (p.get("q")) d3.select("#filtermap").property("value", p.get("q"));
  const c = p.get("cluster");
  if (c !== null && c !== undefined) selectedCluster = c;

  const y0 = parseInt(p.get("y0"));
  const y1 = parseInt(p.get("y1"));
  if (!isNaN(y0)) selectedYearMin = y0;
  if (!isNaN(y1)) selectedYearMax = y1;
}
function pushState() {
  const s = getState();
  const p = new URLSearchParams();
  if (s.q) p.set("q", s.q);
  if (s.cluster !== null && s.cluster !== undefined && s.cluster !== "null") p.set("cluster", s.cluster);
  if (s.y0 !== null && s.y0 !== undefined) p.set("y0", s.y0);
  if (s.y1 !== null && s.y1 !== undefined) p.set("y1", s.y1);
  const u = `${location.pathname}?${p.toString()}`;
  history.replaceState(null, "", u);
}

/* ----------------- Initial zoom / reset ----------------- */
function applyInitialZoom() {
  const t = d3.zoomIdentity
    .translate(width / 2, height / 2)
    .scale(0.45)
    .translate(-width / 2, -height / 2);
  d3.select("#paperviz svg").call(zoom.transform, t);
  currentTransform = t;
}

/* ----------------- ResizeObserver for responsiveness ----------------- */
function resize() {
  const parent = document.getElementById("paperviz");
  const w = Math.max(280, parent.clientWidth) - margin.left - margin.right;
  const h = Math.max(260, Math.round(w * 0.66));
  width = w; height = h;

  d3.select("#paperviz svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);

  x.range([0, width]);
  y.range([height, 0]);

  updateVisualization();
}
const ro = new ResizeObserver(resize);
ro.observe(document.getElementById("paperviz"));
resize();

/* ----------------- Data load & visualization ----------------- */
Promise.all([
  d3.json('./tsne_clustered.json'),
  d3.json('cluster_summary.json')
]).then(function(results) {
  const data = results[0];
  const summary = results[1];

  allData = data;
  allData.forEach(function(d) {
    d.year = parseInt(d.year);
    d.citations = +d.citations || 0;

    const authors = Array.isArray(d.authors) ? d.authors.join(" ") : (d.authors || "");
    d._searchText = [
      d.title || "",
      d.abstract || "",
      (d.tags || []).join(" "),
      authors,
      d.conference || "",
      d.key || "",
      d.year || ""
    ].join(" ").toLowerCase();
  });

  // Determine year bounds from data
  const years = allData.map(d => d.year).filter(y => !isNaN(y));
  yearMinBound = d3.min(years);
  yearMaxBound = d3.max(years);

  // Apply URL state first (may override default selection)
  setStateFromURL();

  // Default selection to full range if not set by URL
  if (selectedYearMin === null) selectedYearMin = yearMinBound;
  if (selectedYearMax === null) selectedYearMax = yearMaxBound;

  // Init year controls and show them
  const yearControls = document.getElementById("yearControls");
  const yearMinInput = document.getElementById("yearMin");
  const yearMaxInput = document.getElementById("yearMax");
  const yearMinVal = document.getElementById("yearMinVal");
  const yearMaxVal = document.getElementById("yearMaxVal");
  const clearYearBtn = document.getElementById("clearYear");

  yearMinInput.min = yearMinBound;
  yearMinInput.max = yearMaxBound;
  yearMaxInput.min = yearMinBound;
  yearMaxInput.max = yearMaxBound;

  yearMinInput.value = selectedYearMin;
  yearMaxInput.value = selectedYearMax;
  yearMinVal.textContent = selectedYearMin;
  yearMaxVal.textContent = selectedYearMax;

  yearControls.style.display = "flex";

  function clampYearInputs(){
    let v0 = parseInt(yearMinInput.value);
    let v1 = parseInt(yearMaxInput.value);
    if (v0 > v1) { // keep thumbs ordered
      const tmp = v0; v0 = v1; v1 = tmp;
      yearMinInput.value = v0;
      yearMaxInput.value = v1;
    }
    selectedYearMin = v0;
    selectedYearMax = v1;
    yearMinVal.textContent = v0;
    yearMaxVal.textContent = v1;
  }

  let yearDebounce;
  yearMinInput.addEventListener("input", function(){
    clampYearInputs();
    clearTimeout(yearDebounce);
    yearDebounce = setTimeout(updateVisualization, 80);
  });
  yearMaxInput.addEventListener("input", function(){
    clampYearInputs();
    clearTimeout(yearDebounce);
    yearDebounce = setTimeout(updateVisualization, 80);
  });
  clearYearBtn.addEventListener("click", function(){
    selectedYearMin = yearMinBound;
    selectedYearMax = yearMaxBound;
    yearMinInput.value = selectedYearMin;
    yearMaxInput.value = selectedYearMax;
    yearMinVal.textContent = selectedYearMin;
    yearMaxVal.textContent = selectedYearMax;
    updateVisualization();
  });

  // Build legend dynamically
  const legendContainer = d3.select("#cluster-legend");
  const countsByCluster = d3.rollup(allData, v => v.length, d => String(d.cluster));

  Object.entries(summary).forEach(([cluster, tags]) => {
    const count = countsByCluster.get(String(cluster)) || 0;
    const item = legendContainer.append("div")
      .attr("class", "legend-item")
      .style("border-left", `6px solid ${color(cluster)}`)
      .style("padding-left", "8px")
      .on("click", function() {
        selectedCluster = (selectedCluster === cluster ? null : cluster);
        legendContainer.selectAll(".legend-item").style("outline", "none");
        if (selectedCluster !== null) d3.select(this).style("outline", "2px solid #ddd");
        updateVisualization();
      });

    const displayCluster = (Number(cluster) + 1);
    item.append("div")
      .attr("class", "legend-title")
      .text(`Cluster ${displayCluster} (${count} papers)`);

    (tags || []).slice(0, 6).forEach(tag => {
      item.append("div")
        .attr("class", "legend-tag")
        .text(tag.tag);
    });
  });

  d3.select("#resetClusters").on("click", function() {
    selectedCluster = null;
    legendContainer.selectAll(".legend-item").style("outline", "none");
    updateVisualization();
  });

  // Update function (with year filtering)
  updateVisualization = function() {
    var searchTerm = (d3.select("#filtermap").property("value") || "").toLowerCase();

    filteredData = allData.filter(d => {
      const textMatch = !searchTerm || isMatch(d, searchTerm);
      const clusterMatch = (selectedCluster === null) || (String(d.cluster) === String(selectedCluster));
      const hasYear = !isNaN(d.year);
      const yearMatch = hasYear ? (d.year >= selectedYearMin && d.year <= selectedYearMax) : true; // include if no year
      return textMatch && clusterMatch && yearMatch;
    });

    var circles = zoomLayer.selectAll("circle").data(filteredData, d => d.key);
    circles.exit().remove();

    circles
      .on("mouseover", mouseover)
      .on("mousemove", mousemove)
      .on("mouseleave", mouseleave)
      .on("click", click_link)
      .transition().duration(300)
      .attr("cx", d => x(d.tsne_embedding[0]))
      .attr("cy", d => y(d.tsne_embedding[1]))
      .attr("r", d => {
        const byCites = d3.select("#sizeByCitations").property("checked");
        const r = byCites ? Math.sqrt(d.citations || 0) + 3 : 8;
        return Math.min(r, 30);
      })
      .style("fill", d => {
        const st = (d3.select("#filtermap").property("value") || "").toLowerCase();
        return isMatch(d, st) ? "#aa0000" : color(d.cluster);
      })
      .style("opacity", 0.85)
      .style("stroke", "white");

    circles.enter()
      .append("circle")
      .attr("cx", d => x(d.tsne_embedding[0]))
      .attr("cy", d => y(d.tsne_embedding[1]))
      .attr("r", d => {
        const byCites = d3.select("#sizeByCitations").property("checked");
        const r = byCites ? Math.sqrt(d.citations || 0) + 3 : 8;
        return Math.min(r, 30);
      })
      .style("fill", d => {
        const st = (d3.select("#filtermap").property("value") || "").toLowerCase();
        return isMatch(d, st) ? "#aa0000" : color(d.cluster);
      })
      .style("opacity", 0.85)
      .style("stroke", "white")
      .on("mouseover", mouseover)
      .on("mousemove", mousemove)
      .on("mouseleave", mouseleave)
      .on("click", click_link);

    d3.select("#matchCount").text("Matching papers: " + filteredData.length);
    pushState();

    const loader = document.getElementById("loadingViz");
    if (loader) loader.style.display = "none";
  };

  // Initial zoom and first render
  applyInitialZoom();
  updateVisualization();

  // UI bindings
  let debounceTimer;
  d3.select("#filtermap").on("keyup", function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(updateVisualization, 200);
  });

  // Zoom controls (pan via drag; wheel/pinch to zoom)
  d3.select("#zoom_in").on("click", () =>
    d3.select("#paperviz svg").transition().call(zoom.scaleBy, 1.2)
  );
  d3.select("#zoom_out").on("click", () =>
    d3.select("#paperviz svg").transition().call(zoom.scaleBy, 0.8)
  );
  d3.select("#reset_view").on("click", () => {
    applyInitialZoom();
    const hint = document.getElementById("gestureHint");
    if (hint){ hint.classList.add("show"); setTimeout(()=>hint.classList.remove("show"), 1500); }
  });

  d3.select("#sizeByCitations").on("change", updateVisualization);

  // One-time gesture hint on first load
  (function gestureHintOnce(){
    const hint = document.getElementById("gestureHint");
    if (!hint) return;
    if (localStorage.getItem("paperviz-hinted")) return;
    hint.classList.add("show");
    setTimeout(() => hint.classList.remove("show"), 2200);
    localStorage.setItem("paperviz-hinted", "1");
  })();

}).catch(function(err) {
  const loader = document.getElementById("loadingViz");
  if (loader) loader.textContent = "Failed to load data.";
  console.error("Data load error:", err);
});

/* Clear search */
d3.select("#clearSearch").on("click", function() {
  d3.select("#filtermap").property("value", "");
  updateVisualization();
});

/* Keyboard shortcuts */
document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
    e.preventDefault();
    document.getElementById("filtermap").focus();
  } else if (e.key === "Escape") {
    d3.select("#filtermap").property("value", "");
    updateVisualization();
  } else if (e.key.toLowerCase() === "r") {
    const resetBtn = document.getElementById("reset_view");
    if (resetBtn) resetBtn.click();
  }
});
</script>
